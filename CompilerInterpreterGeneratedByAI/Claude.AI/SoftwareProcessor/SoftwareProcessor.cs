using System;
using System.Collections.Generic;

/*
Generated by Claude.AI based on prompt

        Generate a C# class that execute assembly code of a software processor.
        The processor should support all the following operations:
        - Data movement (MOV)
        - Arithmetic operations (ADD, SUB, MUL, DIV)
        - Logical operations (AND, OR, XOR, NOT)
        - Bit shifting (SHL, SHR)
        - Comparison and jumping (CMP, JMP, JE, JNE, JG, JL)
        - Stack operations (PUSH, POP)
        - Subroutine handling (CALL, RET)
        - Program control (HLT)

        Display:
        - Add instruction to print a register to the screen or read a register to the screen.

        Debugger:
        - print to the screen for every instruction executed the state of the processor.

        Assembly Language:
        - Is passed as text


        Write a program in symbolic assembly language to 
        - sum the number from 1 to 10
        - compute the Fibonacci sequence

        Write a program in symbolic assembly language to 
        - compute the Fibonacci sequence

Claude.AI made a few minor mistakes around
- the type of _instructions


 */

namespace SoftwareProcessorNP
{
    public class SoftwareProcessor
    {
        private int[] _registers = new int[8]; // R0 to R7
        private Dictionary<string, int> _labels = new Dictionary<string, int>();
        private List<string> _instructions = new List<string>();
        private Stack<int> _stack = new Stack<int>();
        private Dictionary<string, string> stringData = new Dictionary<string, string>();
        private int _IP = 0;
        private bool _isHalted = false;
        private bool _zeroFlag = false;
        private bool _compareFlag = false;

        public void Reset()
        {
            _registers = new int[8];
            _labels.Clear();
            _instructions.Clear();
            _stack.Clear();
            _IP = 0;
            _isHalted = false;
            _zeroFlag = false;
            _compareFlag = false;
        }

        private static string ProcessLF(string line)
        {
            return line.Replace("\\n", "\r\n");
        }

        public void LoadProgram(string assemblyCode)
        {
            string[] lines = assemblyCode.Split('\n');
            this.Reset();

            // First pass: collect labels
            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i].Trim();
                if (string.IsNullOrEmpty(line) || line.StartsWith(";"))
                    continue;

                if (line.StartsWith(".data"))
                {
                    i++;
                    while (i < lines.Length && !string.IsNullOrEmpty(lines[i].Trim()))
                    {
                        string dataLine = lines[i].Trim();
                        if (dataLine.Contains("DB"))
                        {
                            var parts = dataLine.Split(new[] { "DB" }, StringSplitOptions.RemoveEmptyEntries);
                            string label = parts[0].Trim();
                            string value = parts[1].Trim().Trim('"');
                            stringData[label] = ProcessLF(value);
                        }
                        i++;
                    }
                }
                else if (line.EndsWith(":"))
                {
                    string label = line.TrimEnd(':');
                    _labels[label] = _instructions.Count;
                }
                else
                {
                    _instructions.Add(line);
                }
            }
        }

        public void Execute()
        {
            while (!_isHalted && _IP < _instructions.Count)
            {
                string instruction = _instructions[_IP].ToString();
                if (string.IsNullOrEmpty(instruction))
                {
                    _IP++;
                    continue;
                }

                //PrintProcessorState();
                ExecuteInstruction(instruction);
            }
        }

        private void ExecuteInstruction(string instruction)
        {
            string[] parts = instruction.Split(new[] { ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);
            string opcode = parts[0].ToUpper();

            switch (opcode)
            {
                case "PRINT":
                    Console.WriteLine($"Register {parts[1]} = {GetRegisterValue(GetRegisterIndex(parts[1]))}");
                    _IP++;
                    break;

                case "PRINTS":
                    if (parts[1].StartsWith("\""))
                        Console.Write(ProcessLF(instruction.Replace("PRINTS ", "").Replace(@"""","").Trim()));
                    else
                    {
                        if (stringData.TryGetValue(parts[1], out string value))
                            Console.Write(value);
                        else
                            throw new Exception($"Undefined string: {parts[1]}");
                    }
                    _IP++;
                    break;

                case "MOV":
                    SetRegisterValue(GetRegisterIndex(parts[1]), GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "ADD":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) + GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "SUB":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) - GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "MUL":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) * GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "DIV":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) / GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "AND":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) & GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "OR":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) | GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "XOR":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) ^ GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "NOT":
                    SetRegisterValue(GetRegisterIndex(parts[1]), ~GetRegisterValue(GetRegisterIndex(parts[1])));
                    _IP++;
                    break;

                case "SHL":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) << GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "SHR":
                    SetRegisterValue(GetRegisterIndex(parts[1]),
                        GetRegisterValue(GetRegisterIndex(parts[1])) >> GetOperandValue(parts[2]));
                    _IP++;
                    break;

                case "CMP":
                    int value1 = GetRegisterValue(GetRegisterIndex(parts[1]));
                    int value2 = GetOperandValue(parts[2]);
                    _zeroFlag = value1 == value2;
                    _compareFlag = value1 > value2;
                    _IP++;
                    break;

                case "JMP":
                    _IP = GetJumpTarget(parts[1]);
                    break;

                case "JE":
                    _IP = _zeroFlag ? GetJumpTarget(parts[1]) : _IP + 1;
                    break;

                case "JNE":
                    _IP = !_zeroFlag ? GetJumpTarget(parts[1]) : _IP + 1;
                    break;

                case "JG":
                    _IP = _compareFlag ? GetJumpTarget(parts[1]) : _IP + 1;
                    break;

                case "JL":
                    _IP = (!_compareFlag && !_zeroFlag) ? GetJumpTarget(parts[1]) : _IP + 1;
                    break;

                case "JLE":
                    _IP = (!_compareFlag && _zeroFlag) ? GetJumpTarget(parts[1]) : _IP + 1;
                    break;

                case "PUSH":
                    _stack.Push(GetOperandValue(parts[1]));
                    _IP++;
                    break;

                case "POP":
                    SetRegisterValue(GetRegisterIndex(parts[1]), _stack.Pop());
                    _IP++;
                    break;

                case "CALL":
                    _stack.Push(_IP + 1);
                    _IP = GetJumpTarget(parts[1]);
                    break;

                case "RET":
                    _IP = _stack.Pop();
                    break;

                case "HLT":
                    _isHalted = true;
                    break;

                case "READ":
                    Console.Write($"Enter value for register {parts[1]}: ");
                    SetRegisterValue(GetRegisterIndex(parts[1]), int.Parse(Console.ReadLine()));
                    _IP++;
                    break;

                default:
                    throw new Exception($"Unknown instruction: {opcode}");
            }
        }

        private int GetRegisterIndex(string register)
        {
            if (!register.StartsWith("R") || !int.TryParse(register.Substring(1), out int index) || index < 0 || index >= _registers.Length)
                throw new Exception($"Invalid register: {register}");
            return index;
        }

        private int GetRegisterValue(int index)
        {
            return _registers[index];
        }

        private void SetRegisterValue(int index, int value)
        {
            _registers[index] = value;
        }

        private int GetOperandValue(string operand)
        {
            if (operand.StartsWith("R"))
                return GetRegisterValue(GetRegisterIndex(operand));
            return int.Parse(operand);
        }

        private int GetJumpTarget(string label)
        {
            if (!_labels.ContainsKey(label))
                throw new Exception($"Unknown label: {label}");
            return _labels[label];
        }

        private void PrintProcessorState()
        {
            Console.WriteLine("\nProcessor State:");
            Console.WriteLine($"Instruction Pointer: {_IP}");
            Console.WriteLine($"Current Instruction: {_instructions[_IP]}");
            Console.WriteLine("Registers:");
            for (int i = 0; i < _registers.Length; i++)
            {
                Console.WriteLine($"R{i}: {_registers[i]}");
            }
            Console.WriteLine($"Zero Flag: {_zeroFlag}");
            Console.WriteLine($"Compare Flag: {_compareFlag}");
            Console.WriteLine($"Stack Count: {_stack.Count}");
            Console.WriteLine("------------------------");
        }
    }// Example Usage
}
